# Java 日志框架说明

## 1. 项目中的日志架构

本项目使用 **SLF4J + Logback** 作为日志解决方案：

```
应用代码
   ↓
SLF4J (接口层) - 提供统一的日志API
   ↓
Logback (实现层) - 实际的日志记录和输出
   ↓
日志文件/控制台
```

### 架构优势

- **解耦性**：应用代码只依赖 SLF4J 接口，不依赖具体实现
- **灵活性**：可以随时切换底层日志实现（Logback、Log4j2 等）
- **性能**：参数化日志避免不必要的字符串拼接
- **易用性**：配合 Lombok 的 `@Slf4j` 注解，使用更简洁

## 2. 依赖配置

### pom.xml 配置

```xml
<!-- SLF4J API (日志接口) -->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>2.0.9</version>
</dependency>

<!-- Logback Classic (日志实现，包含核心和经典模块) -->
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.4.14</version>
</dependency>

<!-- Lombok (简化日志代码) -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.30</version>
    <scope>provided</scope>
</dependency>
```

**注意**：Spring Boot 项目中，`spring-boot-starter` 已经包含了 `logback-classic`，通常不需要显式声明。

## 3. 使用方式

### 方式一：传统方式（手动创建 Logger）

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MyService {
    // 手动创建 Logger 实例
    private static final Logger logger = LoggerFactory.getLogger(MyService.class);

    public void doSomething() {
        logger.info("开始执行业务逻辑");
        logger.debug("调试信息：参数值为 {}", param);
        logger.error("发生错误", exception);
    }
}
```

### 方式二：Lombok 注解方式（推荐）

```java
import lombok.extern.slf4j.Slf4j;

@Slf4j  // 自动生成 log 字段
public class MyService {
    public void doSomething() {
        log.info("开始执行业务逻辑");
        log.debug("调试信息：参数值为 {}", param);
        log.error("发生错误", exception);
    }
}
```

**优势**：
- 减少样板代码
- log 字段自动生成，无需手动创建
- 更简洁易读

## 4. 日志级别

从低到高依次为：

| 级别 | 说明 | 使用场景 |
|------|------|---------|
| **TRACE** | 追踪级别 | 最详细的调试信息，通常仅在特殊问题排查时启用 |
| **DEBUG** | 调试级别 | 详细的调试信息，开发环境使用 |
| **INFO** | 信息级别 | 关键业务流程信息，生产环境默认级别 |
| **WARN** | 警告级别 | 潜在问题，不影响系统运行 |
| **ERROR** | 错误级别 | 错误信息，需要关注和处理 |

### 示例代码

```java
@Slf4j
public class LogLevelDemo {
    public void demonstrateLogLevels() {
        log.trace("TRACE - 最详细的追踪信息");
        log.debug("DEBUG - 调试信息，变量值：{}", value);
        log.info("INFO - 用户 {} 登录成功", username);
        log.warn("WARN - 数据库连接池使用率达到 80%");
        log.error("ERROR - 订单处理失败", exception);
    }
}
```

## 5. 核心特性与最佳实践

### 5.1 参数化日志（推荐 ✅）

```java
// ✅ 推荐：使用占位符 {}
log.info("用户 {} 执行了 {} 操作", username, action);
log.debug("查询参数：id={}, name={}", id, name);

// ❌ 不推荐：字符串拼接
log.info("用户 " + username + " 执行了 " + action + " 操作");  // 即使日志级别不满足也会执行拼接
```

**优势**：
- 性能更好：只有日志级别满足时才会进行字符串格式化
- 代码更简洁：避免复杂的字符串拼接

### 5.2 异常日志记录

```java
// ✅ 推荐：将异常作为最后一个参数
try {
    // 业务逻辑
} catch (Exception e) {
    log.error("处理订单 {} 时发生错误", orderId, e);  // 异常对象作为最后一个参数
}

// ❌ 不推荐：将异常转换为字符串
log.error("错误信息：" + e.getMessage());  // 丢失了堆栈信息
```

### 5.3 MDC（Mapped Diagnostic Context）分布式追踪

MDC 用于在多线程环境中传递上下文信息，常用于分布式系统的链路追踪。

```java
import org.slf4j.MDC;

@Slf4j
public class RequestHandler {
    public void handleRequest(String requestId, Long userId) {
        try {
            // 设置 MDC 上下文
            MDC.put("requestId", requestId);
            MDC.put("userId", String.valueOf(userId));

            log.info("开始处理请求");  // 日志会自动包含 requestId 和 userId
            // 业务逻辑...
            log.info("请求处理完成");

        } finally {
            // 清理 MDC（重要！）
            MDC.clear();
        }
    }
}
```

**配置输出格式**（logback.xml）：
```xml
<pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] [%X{requestId}] [%X{userId}] %-5level %logger{36} - %msg%n</pattern>
```

### 5.4 性能优化

对于复杂的日志信息，建议先判断日志级别：

```java
// ✅ 对于耗时操作，先检查日志级别
if (log.isDebugEnabled()) {
    log.debug("复杂对象：{}", expensiveOperation());  // 仅在 DEBUG 开启时才执行
}

// ✅ 简单参数直接使用占位符（SLF4J 已优化）
log.debug("用户ID：{}", userId);  // 无需检查，性能影响很小
```

## 6. Spring Boot 配置

### application.yml 配置

```yaml
logging:
  level:
    root: INFO                           # 根日志级别
    com.example: DEBUG                   # 自定义包的日志级别
    org.springframework.web: DEBUG       # Spring Web 日志
    org.hibernate.SQL: DEBUG             # SQL 语句
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE  # SQL 参数

  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"

  file:
    name: logs/application.log          # 日志文件路径
    max-size: 10MB                      # 单个文件最大大小
    max-history: 30                     # 保留天数
```

### logback-spring.xml 高级配置

在 `src/main/resources/` 下创建 `logback-spring.xml`：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- 控制台输出 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] [%X{requestId}] %-5level %logger{36} - %msg%n</pattern>
            <charset>UTF-8</charset>
        </encoder>
    </appender>

    <!-- 文件输出 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <maxHistory>30</maxHistory>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>10MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- 根日志配置 -->
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
    </root>

    <!-- 特定包的日志级别 -->
    <logger name="com.example" level="DEBUG"/>
    <logger name="org.springframework.web" level="DEBUG"/>
</configuration>
```

## 7. 项目中的实际应用

### 7.1 Java 基础示例

参考文件：[src/advanced/LoggingDemo.java](src/advanced/LoggingDemo.java)

这个文件提供了完整的 SLF4J + Logback 使用示例，包括：

1. **日志级别演示**：展示 TRACE/DEBUG/INFO/WARN/ERROR 各级别用法
2. **参数化日志**：使用 `{}` 占位符提高性能
3. **异常日志**：正确记录异常堆栈信息
4. **MDC 上下文**：分布式系统和多线程场景的日志追踪
5. **性能优化**：使用 `isDebugEnabled()` 避免不必要的计算

**运行示例**：
```bash
cd /Users/leonwgc/java-start
javac -d target/classes -cp "~/.m2/repository/org/slf4j/slf4j-api/2.0.9/slf4j-api-2.0.9.jar:~/.m2/repository/ch.qos.logback/logback-classic/1.4.14/logback-classic-1.4.14.jar:~/.m2/repository/ch.qos.logback/logback-core/1.4.14/logback-core-1.4.14.jar" src/advanced/LoggingDemo.java
java -cp "target/classes:~/.m2/repository/org/slf4j/slf4j-api/2.0.9/slf4j-api-2.0.9.jar:~/.m2/repository/ch.qos.logback/logback-classic/1.4.14/logback-classic-1.4.14.jar:~/.m2/repository/ch.qos.logback/logback-core/1.4.14/logback-core-1.4.14.jar" advanced.LoggingDemo
```

### 7.2 Spring Boot 示例

项目中所有 Spring Boot 示例都使用 `@Slf4j` 注解：

**TransactionApplication.java**：
```java
@Slf4j
@SpringBootApplication
public class TransactionApplication implements CommandLineRunner {
    public static void main(String[] args) {
        log.info("========================================");
        log.info("启动 Spring Boot 事务管理示例");
        log.info("========================================");
        SpringApplication.run(TransactionApplication.class, args);
    }

    @Override
    public void run(String... args) {
        log.info("初始化测试数据...");
        // 业务逻辑...
    }
}
```

**其他使用 @Slf4j 的示例**：
- InterceptorApplication.java
- RestfulApplication.java
- CacheApplication.java
- ScheduledApplication.java
- 等等...

## 8. 为什么选择 SLF4J + Logback？

### SLF4J（Simple Logging Facade for Java）

- **门面模式**：提供统一的日志接口，应用代码不依赖具体实现
- **业界标准**：最广泛使用的日志门面，Spring Boot 默认选择
- **性能优化**：参数化日志避免不必要的字符串拼接

### Logback

- **性能优异**：比 Log4j 更快，资源消耗更少
- **自动重载**：配置文件修改后自动生效，无需重启
- **丰富功能**：支持异步日志、条件处理、过滤器等
- **原生集成**：由 SLF4J 作者开发，与 SLF4J 无缝集成
- **Spring Boot 默认**：Spring Boot 默认使用 Logback

## 9. 常见问题

### Q1: 日志不输出怎么办？

检查事项：
1. 确认日志级别配置：`logging.level.root=INFO` 或更低
2. 确认 Logback 依赖已正确引入
3. 检查是否有多个日志框架冲突（如同时引入 Log4j）
4. 查看控制台是否有 Logback 初始化错误

### Q2: 如何在不同环境使用不同配置？

使用 Spring Profile：
```xml
<!-- logback-spring.xml -->
<springProfile name="dev">
    <root level="DEBUG">
        <appender-ref ref="CONSOLE"/>
    </root>
</springProfile>

<springProfile name="prod">
    <root level="INFO">
        <appender-ref ref="FILE"/>
    </root>
</springProfile>
```

### Q3: 如何排除 Spring 框架的大量日志？

```yaml
logging:
  level:
    org.springframework: WARN
    org.hibernate: WARN
    com.example: DEBUG  # 只显示自己的包
```

### Q4: 如何实现异步日志？

在 `logback-spring.xml` 中配置异步 Appender：
```xml
<appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
    <appender-ref ref="FILE"/>
    <queueSize>512</queueSize>
    <discardingThreshold>0</discardingThreshold>
</appender>
```

## 10. 学习建议

### 学习路径

1. **基础使用**（1天）
   - 学习 5 种日志级别的使用场景
   - 掌握参数化日志语法
   - 了解异常日志的正确写法
   - 运行 [LoggingDemo.java](src/advanced/LoggingDemo.java)

2. **实战应用**（2天）
   - 在 Spring Boot 项目中使用 `@Slf4j`
   - 配置不同环境的日志级别
   - 实现日志文件轮转
   - 参考项目中的 Spring Boot 示例

3. **进阶特性**（2天）
   - 掌握 MDC 在分布式系统中的应用
   - 学习异步日志提高性能
   - 配置日志过滤和条件输出
   - 集成 ELK（Elasticsearch + Logback + Kibana）日志分析

### 相关资源

- **SLF4J 官方文档**：https://www.slf4j.org/
- **Logback 官方文档**：https://logback.qos.ch/
- **Spring Boot Logging 文档**：https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.logging
- **项目示例**：
  - Java 基础：[src/advanced/LoggingDemo.java](src/advanced/LoggingDemo.java)
  - Spring Boot：[spring-boot-examples/](spring-boot-examples/) 下所有示例

## 11. 总结

本项目的日志方案特点：

✅ **SLF4J 接口 + Logback 实现**：业界标准组合，性能优异
✅ **Lombok @Slf4j 注解**：简化代码，提高开发效率
✅ **参数化日志**：避免不必要的字符串拼接，提升性能
✅ **MDC 支持**：适用于分布式系统的链路追踪
✅ **灵活配置**：通过 application.yml 或 logback-spring.xml 轻松配置
✅ **Spring Boot 集成**：开箱即用，无需额外配置

通过学习本项目的日志使用方式，你将掌握企业级 Java 应用的日志最佳实践！
